<!DOCTYPE html>
<html lang="en">

<head>
  <title>Our simple HTTP server</title>
  <link rel="stylesheet" type="text/css" href="/client/style.css">
</head>

<body>
  <section id="top">
    <h3>Status Code Tests</h3>
    <select id="page">
      <option value="/success">Success</option>
      <option value="/badRequest">Bad Request</option>
      <option value="/unauthorized">Unauthorized</option>
      <option value="/forbidden">Forbidden</option>
      <option value="/internal">Internal</option>
      <option value="/notImplemented">Not Implemented</option>
      <option value="/notFound">Not Found</option>
    </select>
    <select id="type">
      <option value="application/json">JSON</option>
      <option value="text/xml">XML</option>
    </select>
    <button id="send">Send</button>
  </section>
  <section id="content">
  </section>
</body>

<script>
  /*A function for handling our fetch response. Read init and sendFetch first.

  Like sendFetch(), handleResponse() is marked as an async function. This is because we
  make use of the await keyword within it.
  */
  const handleResponse = (response) => {
    //Grab the content section from the page
    const content = document.getElementById('content');

    //Based on the status code we got back from the server, display something.
    switch (response.status) {
      case 200: //Success
        content.innerHTML = `<b>Success</b>`;
        break;
      case 400: //Bad Request
        content.innerHTML = `<b>Bad Request</b>`;
        break;
      case 401: //unauthorized
        content.innerHTML = `<b>Unauthorized</b>`;
        break;
      case 403: //forbidden
        content.innerHTML = `<b>Forbidden</b>`;
        break;
      case 404: //Not Found
        content.innerHTML = `<b>Not Found</b>`;
        break;
      case 500: //Internal
        content.innerHTML = `<b>Internal</b>`;
        break;
      case 501: //Not Implemented
        content.innerHTML = `<b>Not Implemented</b>`;
        break;
      default: //Anything Else
        content.innerHTML = `<p>Status Code not Implemented By Client</p>`;
        break;
    }

    /*Unlike the Accept Header demo, this demo only supports JSON. Because of that, we don't
    need to convert our response to text and then parse that as JSON. JSON is so common that
    the fetch API handles it innately.

    response.json() is an asychronous call that runs on a background thread. This is because
    some json responses can be tremendously large, and processing them takes time. We don't want
    to call the content.innerHTML code below until we have processed the response, so we can
    use the await keyword to await a "fulfilled" promise from response.json().
    */
    response.text().then((resText) => {
      const contentType = response.headers.get('Content-Type');
      console.log("contentType: ", contentType);

      if (contentType.includes('text/xml')) { //If the server sent back xml
        //Parse the xml into a document and select the data out.
        console.log("Raw XML: ", resText);
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(resText, "text/xml");
        // Debug parsed XML output
        console.log("Parsed XML:", new XMLSerializer().serializeToString(xmlDoc));

        const messageElement = xmlDoc.querySelector("message");
        content.innerHTML += `<br> ${messageElement.textContent} </br>`;

      } else {
        const parsedResponse = JSON.parse(resText);
        content.innerHTML += `<br> ${parsedResponse.message} </br>`;
      }
    });


    // let resObj = await response.json();
    // console.log(resObj);

    // //Once the response.json() promise is fulfilled we move to this line, which displays the message.
    // content.innerHTML += `< p > ${resObj.message}</p >`;
  };

  const sendFetch = async (url, type) => {
    //Call fetch, wait til we get a response, and then store that response in the variable.

    const options = {
      method: 'GET',
      headers: { 'Accept': type },
    }

    const fetchPromise = fetch(url, options);
    fetchPromise.then((response) => {
      console.log("fetch response: ", response);
      handleResponse(response)
    });
  };


  /*init is the starting point of our client side code. Below the function, we
    have window.onload = init, which means that init will automatically be called
    when the page loads.
  */
  const getInfo = () => {
    //Grab references to all the buttons on the page.
    const sendButton = document.querySelector("#send");
    console.log(document.querySelector("#page").value);

    const type = document.querySelector("#type").value;

    if (document.querySelector("#page").value === "/success") {
      sendFetch('/success', type);
    } else if (document.querySelector("#page").value === "/badRequest") {
      sendFetch('/badRequest', type);
    } else if (document.querySelector("#page").value === "/unauthorized") {
      sendFetch('/unauthorized', type);
    } else if (document.querySelector("#page").value === "/forbidden") {
      sendFetch('/forbidden', type);
    } else if (document.querySelector("#page").value === "/internal") {
      sendFetch('/internal', type);
    } else if (document.querySelector("#page").value === "/notImplemented") {
      sendFetch('/notImplemented', type);
    } else {
      sendFetch('/notFound', type);
    }
  };

  const sendButton = document.querySelector("#send").addEventListener("click", getInfo);

</script>

</html>